{
    "tiddlers": {
        "$:/plugins/snowgoon88/edit-comptext/config": {
            "title": "$:/plugins/snowgoon88/edit-comptext/config",
            "type": "application/json",
            "text": "{\n  \"configuration\": {\n      \"caseSensitive\" : false,\n      \"maxMatch\" : 8,\n      \"minPatLength\" : 2,\n      \"triggerKeyCombination\" : \"^ \"\n  },\n  \"template\": [{\n      \"pattern\": \"[[\",\n      \"filter\": \"[all[tiddlers]!is[system]]\",\n      \"start\": \"[[\",\n      \"end\": \"]]\"\n      },\n      {\n      \"pattern\": \"||\",\n      \"filter\": \"[all[tiddlers]!is[system]]\",\n      \"start\": \"[[|\",\n      \"end\": \"]]\",\n      \"startOffset\" : 2\n      }\n  ]\n}\n"
        },
        "$:/plugins/snowgoon88/edit-comptext/edit-comptext.js": {
            "title": "$:/plugins/snowgoon88/edit-comptext/edit-comptext.js",
            "text": "/*\\\ntitle: $:/plugins/snowgoon88/edit-comptext/edit-comptext.js\ntype: application/javascript\nmodule-type: widget\n\nTaken from original Edit-text widget\nVersion 5.1.13 of TW5\nAdd link-to-tiddler completion in framed.js and simple.js\n\nTODO : CHECK usefull, and particularly save_changes after every input ??\nTODO : where should popupNode be created in the DOM ?\nTODO : check that options are valid (numeric ?)\nvar isNumeric = function(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n};\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar editTextWidgetFactory = require(\"$:/core/modules/editor/factory.js\").editTextWidgetFactory,\n\tFramedCompEngine = require(\"$:/plugins/snowgoon88/edit-comptext/framed.js\").FramedCompEngine,\n\tSimpleCompEngine = require(\"$:/plugins/snowgoon88/edit-comptext/simple.js\").SimpleCompEngine;\n\nexports[\"edit-comptext\"] = editTextWidgetFactory(FramedCompEngine,SimpleCompEngine);\n\n})();\n",
            "type": "application/javascript",
            "module-type": "widget"
        },
        "$:/plugins/snowgoon88/edit-comptext/examples": {
            "title": "$:/plugins/snowgoon88/edit-comptext/examples",
            "text": "The configuration file [[$:/plugins/snowgoon88/edit-comptext/config]] allow you to use the completion plugin for various usages. Here are some examples...\n\n!! Link Completion\nThe basic and default usage. Completion is triggered by `[[`, the search is among all non-system tiddlers. When selected, the `title` of the tiddler is inserted in the text, surrounded by `[[` and `]]`. This gives the following Completion Template.\n\n\n```\n{\n      \"pattern\": \"[[\",\n      \"title\": \"[all[tiddlers]!is[system]]\",\n      \"start\": \"[[\",\n      \"end\": \"]]\"\n}\t     \n```\n\n!! Link Completion and reposition to add Alias\nAnother basic usage. Completion is triggered by `||`, the search is among all non-system tiddlers. When selected, the `title` of the tiddler is inserted in the text, surrounded by `[[|` and `]]`. The cursor is positionned just before the `|`, ready for typing an Alias.\n\n```\n{\n      \"pattern\": \"||\",\n      \"filter\": \"[all[tiddlers]!is[system]]\",\n      \"start\": \"[[|\",\n      \"end\": \"]]\",\n      \"startOffset\" : 2\n      }\n\n```\n\n!! Special macro completion\nI have a 'pnjin' macro that is invoked by `<<pnjin \"TiddlerPNJName\">>` where 'TiddlerPNJName is a tiddler that hold data about a PNJ. I use tiddlywiki to organise my Role Playing Games campaigns. So, I want `<p` to trigger the completion. The search is among all non-system tiddlers tagged `PNJ` and, once selected, the title of the tiddler must be inserted surrouned by `<<pnjin \\\"` and `\\\">>`. So...\n\n```\n{\n\t\"pattern\": \"<p\",\n      \t\"title\": \"[tag[PNJ]!is[system]]\",\n      \t\"start\": \"<<pnjin  \\\"\",\n      \t\"end\": \"\\\">>\"\n}\n```\n\n!! Insert some templates or stamp or snippets into text.\nI frequently use some text pattern and I want to insert them easily. So, I could create several tiddlers, tagged '$:stamp' and in their body are the piece of texte I want to insert. The titles of these tiddlers always start with `$:/config/stamp/` (i.e. $:/config/stamp/macro, $:/config/stamp/list1, $:/config/stamp/list2). I want to trigger the completion by using `<<`, then I only want to chose among the last part of the titles of tiddlers tagged `$:stamp` so I use a mask (`$:/config/stamp/`) to only display the last part of the tiddlers title. When selectected, the `body` of the tiddler is inserted, with no surrounding strings. As a results, the Completion Template is (notice the `body` field):\n\n```\n{\n      \"pattern\": \"<<\",\n      \"body\": \"[tag[$:stamp]]\",\n      \"mask\" : \"$:/config/stamp/\",\n      \"start\": \"\",\n      \"end\": \"\"\n}\n```\n\n!! And you ?\nIf you have funny usages of completion, let me know. If you'd like to do something that is not yet possible, let me know...\n\nmail : snowgoon88(AT)gmail(DOT)com"
        },
        "$:/plugins/snowgoon88/edit-comptext/framed.js": {
            "text": "/*\\\ntitle: $:/plugins/snowgoon88/edit-comptext/framed.js\ntype: application/javascript\nmodule-type: library\n\nTaken from $:/core/modules/editor/engines/framed.js\nText editor engine based on a simple input or textarea within an iframe. This is done so that the selection is preserved even when clicking away from the textarea\n\n\\*/\n(function(){\n\n/*jslint node: true,browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar HEIGHT_VALUE_TITLE = \"$:/config/TextEditor/EditorHeight/Height\";\n\n// Configuration tiddler\nvar COMPLETION_OPTIONS = \"$:/plugins/snowgoon88/edit-comptext/config\";\nvar Completion = require(\"$:/plugins/snowgoon88/edit-comptext/completion.js\").Completion;\nvar FramedEngine = require(\"$:/core/modules/editor/engines/framed.js\").FramedEngine;\n\t\nfunction FramedCompEngine(options) {\n\tFramedEngine.call(this,options);\n\tthis._configOptions = $tw.wiki.getTiddlerData( COMPLETION_OPTIONS, {} );\n\tthis._completion = new Completion( this.widget, this.domNode, this._configOptions, this.dummyTextArea, this.iframeNode.offsetTop, this.iframeNode.offsetLeft );\n};\n\nFramedCompEngine.prototype = Object.create(FramedEngine.prototype);\n\nFramedCompEngine.prototype.constructor = FramedCompEngine;\n\nexports.FramedCompEngine = FramedCompEngine;\n$tw.modules.types.library[\"$:/core/modules/editor/engines/framed.js\"].exports.FramedEngine = FramedCompEngine;\n})();\n",
            "type": "application/javascript",
            "title": "$:/plugins/snowgoon88/edit-comptext/framed.js",
            "module-type": "startup"
        },
        "$:/plugins/snowgoon88/edit-comptext/simple.js": {
            "text": "/*\\\ntitle: $:/plugins/snowgoon88/edit-comptext/simple.js\ntype: application/javascript\nmodule-type: library\n\nTaken from $:/core/modules/editor/engines/simple.js\nText editor engine based on a simple input or textarea tag\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar HEIGHT_VALUE_TITLE = \"$:/config/TextEditor/EditorHeight/Height\";\n\n// Configuration tiddler\nvar COMPLETION_OPTIONS = \"$:/plugins/snowgoon88/edit-comptext/config\";\nvar Completion = require(\"$:/plugins/snowgoon88/edit-comptext/completion.js\").Completion;\nvar SimpleEngine = require(\"$:/core/modules/editor/engines/simple.js\").SimpleEngine;\n\t\nfunction SimpleCompEngine(options) {\n\tSimpleEngine.call(this,options);\n\tthis._configOptions = $tw.wiki.getTiddlerData( COMPLETION_OPTIONS, {} );\n\tthis._completion = new Completion( this.widget, this.domNode, this._configOptions );\n};\n\nSimpleCompEngine.prototype = Object.create(SimpleEngine.prototype);\n\nSimpleCompEngine.prototype.constructor = SimpleCompEngine;\n\n\nexports.SimpleCompEngine = SimpleCompEngine;\n$tw.modules.types.library[\"$:/core/modules/editor/engines/simple.js\"].exports.SimpleEngine = SimpleCompEngine;\n})();\n",
            "type": "application/javascript",
            "title": "$:/plugins/snowgoon88/edit-comptext/simple.js",
            "module-type": "startup"
        },
        "$:/plugins/snowgoon88/edit-comptext/cursor-position.js": {
            "text": "/*\\\nModule that compute the pixel position of the cursor of a text\nements.\n\nTaken from https://github.com/component/textarea-caret-position\n\n(as https://github.com/kir/js_cursor_position is not updated any more)\n\\*/\n// Fonction anonyme executée immediatement\n( function(){\n \n// The properties that we copy into a mirrored div.\n// Note that some browsers, such as Firefox,\n// do not concatenate properties, i.e. padding-top, bottom etc. -> padding,\n// so we have to do every single property specifically.\nvar properties = [\n  'direction',  // RTL support\n  'boxSizing',\n  'width',  // on Chrome and IE, exclude the scrollbar, so the mirror div wraps exactly as the textarea does\n  'height',\n  'overflowX',\n  'overflowY',  // copy the scrollbar for IE\n\n  'borderTopWidth',\n  'borderRightWidth',\n  'borderBottomWidth',\n  'borderLeftWidth',\n  'borderStyle',\n\n  'paddingTop',\n  'paddingRight',\n  'paddingBottom',\n  'paddingLeft',\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/font\n  'fontStyle',\n  'fontVariant',\n  'fontWeight',\n  'fontStretch',\n  'fontSize',\n  'fontSizeAdjust',\n  'lineHeight',\n  'fontFamily',\n\n  'textAlign',\n  'textTransform',\n  'textIndent',\n  'textDecoration',  // might not make a difference, but better be safe\n\n  'letterSpacing',\n  'wordSpacing',\n\n  'tabSize',\n  'MozTabSize'\n\n];\nvar isFirefox = false;\nif($tw.browser) {\n    isFirefox = window.mozInnerScreenX != null;\n}\n\nfunction getCaretCoordinates(element, position, options) {\n\n  var debug = options && options.debug || false;\n  if (debug) {\n    var el = document.querySelector('#input-textarea-caret-position-mirror-div');\n    if ( el ) { el.parentNode.removeChild(el); }\n  }\n\n  // mirrored div\n  var div = document.createElement('div');\n  div.id = 'input-textarea-caret-position-mirror-div';\n  document.body.appendChild(div);\n\n  var style = div.style;\n  var computed;\n  if($tw.browser) {\n      computed = window.getComputedStyle? getComputedStyle(element) : element.currentStyle;  // currentStyle for IE < 9\n  } \n  else {\n      computed = element.currentStyle;\n  }\n    \n\n  // default textarea styles\n  style.whiteSpace = 'pre-wrap';\n  if (element.nodeName !== 'INPUT')\n    style.wordWrap = 'break-word';  // only for textarea-s\n\n  // position off-screen\n  style.position = 'absolute';  // required to return coordinates properly\n  if (!debug)\n    style.visibility = 'hidden';  // not 'display: none' because we want rendering\n\n  // transfer the element's properties to the div\n  properties.forEach(function (prop) {\n    style[prop] = computed[prop];\n  });\n\n  if (isFirefox) {\n    // Firefox lies about the overflow property for textareas: https://bugzilla.mozilla.org/show_bug.cgi?id=984275\n    if (element.scrollHeight > parseInt(computed.height))\n      style.overflowY = 'scroll';\n  } else {\n    style.overflow = 'hidden';  // for Chrome to not render a scrollbar; IE keeps overflowY = 'scroll'\n  }\n\n  div.textContent = element.value.substring(0, position);\n  // the second special handling for input type=\"text\" vs textarea: spaces need to be replaced with non-breaking spaces - http://stackoverflow.com/a/13402035/1269037\n  if (element.nodeName === 'INPUT')\n    div.textContent = div.textContent.replace(/\\s/g, \"\\u00a0\");\n\n  var span = document.createElement('span');\n  // Wrapping must be replicated *exactly*, including when a long word gets\n  // onto the next line, with whitespace at the end of the line before (#7).\n  // The  *only* reliable way to do that is to copy the *entire* rest of the\n  // textarea's content into the <span> created at the caret position.\n  // for inputs, just '.' would be enough, but why bother?\n  span.textContent = element.value.substring(position) || '.';  // || because a completely empty faux span doesn't render at all\n  div.appendChild(span);\n\n  var coordinates = {\n    top: span.offsetTop + parseInt(computed['borderTopWidth']),\n    left: span.offsetLeft + parseInt(computed['borderLeftWidth'])\n  };\n\n  if (debug) {\n    span.style.backgroundColor = '#aaa';\n  } else {\n    document.body.removeChild(div);\n  }\n\n  return coordinates;\n}\n\n// Exporte as a module of node.js otherwise set as global\nif (typeof module != \"undefined\" && typeof module.exports != \"undefined\") {\n  module.exports = getCaretCoordinates;\n} else {\n  window.getCaretCoordinates = getCaretCoordinates;\n}\n\n})();\n",
            "type": "application/javascript",
            "title": "$:/plugins/snowgoon88/edit-comptext/cursor-position.js",
            "module-type": "library"
        },
        "$:/plugins/snowgoon88/edit-comptext/completion.js": {
            "text": "/*\\\ntitle: $:/plugins/snowgoon88/edit-comptext/completion.js\ntype: application/javascript\nmodule-type: library\n\nTry to make self-contained completion module.\n\nTo use this 'module', you need a `widget` with a kind of `editarea` node.\nI do not know the exacte prerequisites of this editarea node for the module to\nwork, but mostly one should be able to attach the following `eventHandler` to\nit:\n - input\n - keydown\n - keypress\n - keyup\nThe `widget` is needed because I use:\n - widget.document\n - widget.wiki.filterTiddlers(...)\n\nFrom the Widget, once you have a proper editarea, you just have to call\n - var completion = new Completion( theWidget, theEditAreaNode, configObject);\nwhere `configObject` is expected to have the following fields. if a field is missing, a default value will be given.\nOne can have many `elements' in the template array.\n\n{\n  \"configuration\": {\n      \"caseSensitive\" : false,\n      \"maxMatch\" : 8,\n      \"minPatLength\" : 2,\n      \"triggerKeyCombination\" : \"^ \"\n  },\n  \"template\": [{\n      \"pattern\": \"[[\",\n      \"filter\": \"[all[tiddlers]!is[system]]\",\n      \"start\": \"[[\",\n      \"end\": \"]]\"\n      }\n  ]\n}\n\nTODO : CHECK if needed\n\\*/\n\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\n// To compute pixel coordinates of cursor\nvar getCaretCoordinates = require(\"$:/plugins/snowgoon88/edit-comptext/cursor-position.js\");\n\n/** Default Completion Attributes */\nvar DEFATT = { maxMatch: 5, minPatLength: 2, caseSensitive: false, triggerKeyCombination: \"^ \" };\n\n/** \n * Struct for generic Completion Templates.\n * <ul>\n * <li>pat : pattern searched for.</li>\n * <li>filter : filter operation used to find the list of completion options</li>\n * <li>mask: replaced by \"\" when presenting completion options</li>\n * </ul>\n */\n    var Template = function( pat, filter, mask, field, start, end, startOffset  ) {\n    this.pat = pat;\n        this.filter = filter;\n    this.mask = \"^\"+regExpEscape(mask);\n    this.field = field;\n    this.start = start;\n    this.end = end;\n        this.pos = 0;\n        this.startOffset  = startOffset;\n};\n/**\n * Struct for storing completion options, as we need to memorise \n * the titles of the tiddlers when masked and when body must be displayed.\n */\nvar OptCompletion = function( title, str ) {\n    this.title = title;\n    this.str = str;\n};\n\nvar keyMatchGenerator = function(combination) {\n\tlet singleMatchGenerator = function(character) {\n\t\tif (character === '^') {\n\t\t\treturn event => event.ctrlKey;\n\t\t}\n\t\telse if (character === '+') {\n\t\t\treturn event => event.shiftKey;\n\t\t}\n\t\telse if (character === '!') {\n\t\t\treturn event => event.altKey;\n\t\t}\n\t\telse {\n\t\t\treturn event => (event.keyCode || event.which) === character.charCodeAt(0);\n\t\t}\n\t};\n\n\tlet matchers = [];\n\tfor (let i = 0; i < combination.length; i++) {\n\t\tmatchers.push(singleMatchGenerator(combination[i]));\n\t}\n\n\treturn event => {\n\t\tfor (let i = 0; i < matchers.length; i++) {\n\t\t\tif (!matchers[i](event)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n};\n\n/**\n * Widget is needed in creating popupNode.\n * - widget.document\n * - widget.wiki.filterTiddlers(...)\n * - sibling : where to create the popup in the DOM.\n */\n\tvar Completion = function( editWidget, areaNode, param, sibling, offTop, offLeft ) {\n\tconsole.log( \"==Completion::creation\" );\n\n\t//check if the widget uses the framed engine\n\tif(typeof sibling !== 'undefined') {\n\t\t//The framed engine propagates all keydown events to the parent document\n\t\t//Disable this and only propagate keydown events not handled by the autocompletion in our handleKeydown method\n\t\teditWidget._original_handleKeydownEvent = editWidget.handleKeydownEvent;\n\t\teditWidget.handleKeydownEvent = function(event) {\n\t\t\treturn false;\n\t\t};\n\t}\n\n    // About underlying Widget\n    this._widget = editWidget;\n\tthis._areaNode = areaNode;\n\tthis._sibling  = (typeof sibling !== 'undefined') ?  sibling : this._areaNode;\n\tthis._offTop = (typeof offTop !== 'undefined') ?  offTop : 0;\n\tthis._offLeft = (typeof offLeft !== 'undefined') ?  offLeft : 0;\t\n\t\t\n    // Completions attributes\n    /** State */\n    this._state = \"VOID\";\n    this._template = undefined;\n    /** Best matches */\n    this._bestMatches = []; // An array of OptCompletion\n    this._idxChoice = -1;\n    /** Param */\n            // maximum nb of match displayed\n            //DEBUG console.log( \"__PARAM\" );\n            //DEBUG console.log( param.configuration );\n    this._maxMatch     = param.configuration.maxMatch || DEFATT.maxMatch;   \n            // Beware that a (0 || 2) gives 2 !, so change way attributs are checked.\n            this._minPatLength = DEFATT.minPatLength;\n            if ('minPatLength' in param.configuration) {\n                this._minPatLength = param.configuration.minPatLength;\n            }\n    this._caseSensitive= param.configuration.caseSensitive || DEFATT.caseSensitive;\n    this._triggerKeyMatcher = keyMatchGenerator(param.configuration.triggerKeyCombination || DEFATT.triggerKeyCombination);\n    /** Input information */\n    this._lastChar = \"\";\n    this._hasInput = false;\n    /** List of Completion Templates */\n    this._listTemp = [];\n    \n    // Read templates from Param\n    if( param.template ) {\n    \tvar idT;\n    \tfor( idT=0; idT<param.template.length; idT++ ) {\n    \t    var temp = param.template[idT];\n\t    // field 'body' ou 'title' (default)\n\t    if( temp.body ) {\t\t\n    \t\tthis._listTemp.push( \n    \t\t    new Template( temp.pattern, temp.body,\n\t\t\t\t  temp.mask ? temp.mask : \"\",\n\t\t\t\t  \"body\",\n    \t\t\t\t  temp.start, temp.end,\n                                temp.startOffset)\n    \t\t);\n\t    }\n\t    else {\n    \t\tthis._listTemp.push( \n    \t\t    new Template( temp.pattern, \n\t\t\t\t  temp.title ? temp.title : temp.filter,\n\t\t\t\t  temp.mask ? temp.mask : \"\",\n\t\t\t\t  \"title\",\n    \t\t\t\t  temp.start, temp.end,\n                                temp.startOffset )\n    \t\t);\n\t    }\n\t    //DEBUG temp = this._listTemp[this._listTemp.length-1];\n\t    //DEBUG console.log( \"__CONF : \"+temp.pattern+\":\"+temp.filter+\":\"+temp.mask+\":\"+temp.field+\":\"+temp.start+\":\"+temp.end );\n    \t}\n    }\n    // or defaut template\n    else {\n    \tthis._listTemp = [\n    \t    new Template( \"[[\", \"[all[tiddlers]!is[system]]\", \n\t\t\t  \"\", \"title\",\n\t\t\t  \"[[\", \"]]\" )\n    \t];\n    }\n    // Create Popup\n\t//this._popNode = createPopup(this._widget, this._areaNode );\n\tthis._popNode = createPopup(this._widget, this._sibling );\t\n    \n    // Listen to the Keyboard\n    $tw.utils.addEventListeners( this._areaNode,[\n\t{name: \"input\", handlerObject: this, handlerMethod: \"handleInput\"},\n\t{name: \"keydown\", handlerObject: this, handlerMethod: \"handleKeydown\"},\n\t{name: \"keypress\", handlerObject: this, handlerMethod: \"handleKeypress\"},\n    \t{name: \"keyup\", handlerObject: this, handlerMethod: \"handleKeyup\"}\n    ]);\n   \n    /** \n     * Find the bestMatches among listChoice with given pattern\n     * @param listChoice : array of String\n     * @change : this._bestMatches => array of OptCompletion\n     */\n    this._findBestMatches = function( listChoice, pattern, nbMax) {\n\t// regexp search pattern, case sensitive\n\tvar flagSearch = this._caseSensitive ? \"\" : \"i\" ;\n\tvar regpat = RegExp( regExpEscape(pattern), flagSearch );\n\tvar regpat_start = RegExp( \"^\"+regExpEscape(pattern), flagSearch );\n\tvar regMask = RegExp( this._template.mask ? this._template.mask : \"\",\"\");\n\tvar nbMatch = 0;\n\t// nbMax set to _maxMatch if no value given\n\tnbMax = nbMax !== undefined ? nbMax : this._maxMatch;\n\n\t//DEBUG console.log( \"__FIND masked=\"+regMask+\" regPat=\"+regpat);\n\n\tthis._bestMatches= [];\n\tvar otherMatches = [];\n\t// We test every possible choice\n\tfor( var i=0; i< listChoice.length; i++ ) {\n\t    // apply mask over potential choice\n\t    var maskedChoice = listChoice[i].replace( regMask, \"\");\n\t    // Test first if pattern is found at START of the maskedChoice\n\t    // THEN added to BestMatches\n \t    if( regpat_start.test( maskedChoice )) {\n\t\tif (nbMatch >= nbMax) {\n\t\t    this._bestMatches.push( new OptCompletion(\"\",\"...\") );\n\t\t    return;\n\t\t} else {\n\t\t    this._bestMatches.push( new OptCompletion(listChoice[i],maskedChoice) );\n\t\t    nbMatch += 1;\n\t\t}\n\t    }\n\t    // then if pattern is found WITHIN the maskedChoice\n\t    // added AFTER the choices that starts with pattern\n\t    else if( regpat.test( maskedChoice ) ) {\n\t\tif (nbMatch >= nbMax) {\n\t\t    // add all otherMatches to _bestMatches\n\t\t    this._bestMatches.push( new OptCompletion(\"\",\"<hr>\") ) ; //separator\n\t\t    this._bestMatches = this._bestMatches.concat( otherMatches );\n\t\t    this._bestMatches.push( new OptCompletion(\"\",\"...\") );\n\t\t    return;\n\t\t} else {\n\t\t    otherMatches.push( new OptCompletion(listChoice[i],maskedChoice) );\n\t\t    nbMatch += 1;\n\t\t}\n\t    }\n\t}\n\t// Here, must add the otherMatches\n\tthis._bestMatches.push( new OptCompletion(\"\",\"<hr>\") ) ; //separator\n\tthis._bestMatches = this._bestMatches.concat( otherMatches );\n    };\n    /**\n     * Change Selected Status of Items\n     */\n    this._next = function (node) {\n\tvar count = node.children.length;\n\t//DEBUG console.log( \"__NEXT: co=\"+count+\" nbMatch=\"+this._bestMatches.length);\n\tif( this._bestMatches.length > 0 ) \n\t    this._goto( node, this._idxChoice < count - 1 ? this._idxChoice + 1 : -1);\n\t//DEBUG this._logStatus( \"NexT\" );\n    };\n    this._previous = function (node) {\n\tvar count = node.children.length;\n\tvar selected = this._idxChoice > -1;\n\t//DEBUG console.log( \"__PREV: co=\"+count+\" nbMatch=\"+this._bestMatches.length);\n\tif( this._bestMatches.length > 0 ) \n\t    this._goto( node, selected ? this._idxChoice - 1 : count - 1);\n\t//DEBUG this._logStatus( \"PreV\" );\n    };\n    // Should not be used, highlights specific item without any checks!\n    this._goto = function (node, idx) {\n\tvar lis = node.children;\n\tvar selected = this._idxChoice > -1;\n\tif (selected) {\n\t    lis[this._idxChoice].setAttribute(\"patt-selected\", \"false\");\n\t}\n\n\tthis._idxChoice = idx;\n    \n\tif (idx > -1 && lis.length > 0) {\n\t    lis[idx].setAttribute(\"patt-selected\", \"true\");\n\t}\n    };\n    /**\n     * Abort pattern and undisplay.\n     */\n    this._abortPattern = function (displayNode) {\n\tthis._state = \"VOID\";\n\tthis._bestChoices = [];\n\tthis._idxChoice = -1;\n\tthis._undisplay( displayNode );\n\tthis._template = undefined;\n    };\n    /**\n     * Display popupNode at the cursor position in areaNode.\n     */\n    this._display = function( areaNode, popupNode ) {\n\tif ( popupNode.style.display == 'none' ) {\n\t    // Must get coordinate\n\t    // Cursor coordinates within area + area coordinates + scroll\n            var coord = getCaretCoordinates(areaNode, areaNode.selectionEnd);\n            var styleSize = getComputedStyle(areaNode).getPropertyValue('font-size');\n            var fontSize = parseFloat(styleSize); \n\t\t\n\t    popupNode.style.left = (this._offLeft+areaNode.offsetLeft-areaNode.scrollLeft+coord.left) + 'px';\n\t    popupNode.style.top = (this._offTop+areaNode.offsetTop-areaNode.scrollTop+coord.top+fontSize*2) + 'px';\n\t    popupNode.style.display = 'block';\n\t}\n    };\n    /**\n     * Undisplay someNode\n     */\n    this._undisplay = function( displayNode ) {\n\tif ( displayNode.style.display != 'none' ) {\n\t    displayNode.style.display = 'none';\n\t}\n    };\n\n     /**\n     * Used for debug\n     */\n    this._logStatus = function(msg) {\n\tconsole.log( \"__STATUS: \"+this._state+\":-\"+msg+\"- idx=\"+this._idxChoice );\n    };\n\n};\n// **************************************************************************\n// ******************************************************************eventCbk\n// **************************************************************************\n/**\n * Disable the *effects* of ENTER / UP / DOWN / ESC when needed.\n * Set _hasInput to false.\n */\nCompletion.prototype.handleKeydown = function(event) {\n    // key \n    var key = event.keyCode;\n    this._hasInput = false;\n    \n    //DEBUG console.log( \"__KEYDOWN (\"+key+\") hasI=\"+this._hasInput);\n    \n    // ENTER while selecting\n    if( (this._state === \"PATTERN\" || this._state === \"SELECT\") && key === 13 ) {\n    \tevent.preventDefault();\n    \tevent.stopPropagation();\n    }\n    // ESC while selecting\n    else if( (this._state === \"PATTERN\" || this._state === \"SELECT\") && key === 27 ) {\n    \tevent.preventDefault();\n    \tevent.stopPropagation();\n    }\n    // UP/DOWN while a pattern is extracted\n    else if( (key===38 || key===40) && \n\t(this._state === \"PATTERN\" || this._state === \"SELECT\") ) {\n\t\tevent.preventDefault();\n    } else {\n\t\t//If we have not handled the keydown event, allow the widget to propagate it to the parent document\n\t\tif(this._widget._original_handleKeydownEvent) {\n\t\t\tthis._widget._original_handleKeydownEvent(event);\n\t\t}\n\t}\n};\n/**\n * Means that something has been added/deleted => set _hasInput\n */\nCompletion.prototype.handleInput = function(event) {\n    this._hasInput = true;\n    //DEBUG console.log( \"__INPUT hasI=\"+this._hasInput );\n};\n\t\n/**\n * Set _lastChar, detects CTRL+SPACE.\n */\nCompletion.prototype.handleKeypress = function(event) {\n    var curPos = this._areaNode.selectionStart;  // cursor position\n    var val = this._areaNode.value;   // text in the area\n    // key \n    var key = event.keyCode || event.which;\n\t\n    this._lastChar = String.fromCharCode(key);\n    //DEBUG console.log( \"__KEYPRESS (\"+key+\") hasI=\"+this._hasInput+\" char=\"+this._lastChar );\n    //DEBUG this._logStatus( \"KEYPRESS\" );\n    \n    // Detect Ctrl+Space\n    if( this._triggerKeyMatcher(event) && this._state === \"VOID\" ) {\n\t//Find a proper Template\n\t// first from which we can extract a pattern\n\tif( this._template === undefined ) {\n\t    //DEBUG console.log(\"__SPACE : find a Template\" );\n\t    var idT, res;\n\t    for( idT=0; idT < this._listTemp.length; idT++ ) {\n\t\tres = extractPattern( val, curPos, this._listTemp[idT] );\n\t\t//DEBUG console.log(\"  t=\"+this._listTemp[idT].pat+\" res=\"+res);\n\t\t// res is not undefined => good template candidate\n\t\tif( res ) {\n\t\t    this._template = this._listTemp[idT];\n\t\t    this._state = \"PATTERN\";\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse {\n\t    //DEBUG console.log(\"__SPACE : already a template\" );\n\t    this._state = \"PATTERN\";\n\t}\n    }\n};\n/**\n * ESC -> abort; \n * Detect [ -> VOID switch to _state=PATTERN\n * PATTERN || SELECT : ENTER -> insertText\n *                     UP/DOWN -> previous/next\n *                     pattern.length > _minPatternLength -> display  \n */\nCompletion.prototype.handleKeyup = function(event) {\n    var curPos = this._areaNode.selectionStart;  // cursor position\n    var val = this._areaNode.value;   // text in the area\n    // key a\n    var key = event.keyCode;\n    \n    //DEBUG console.log( \"__KEYUP (\"+key+\") hasI=\"+this._hasInput );\n\n  // ESC\n    if( key === 27 ) {\n\tthis._abortPattern( this._popNode );\n\t//DEBUG this._logStatus( \"\" );\n    }\n    // Check for every template\n    if( this._hasInput && this._state === \"VOID\" ) {\n\t// check every template's pattern\n\tvar idT, template;\n\tfor( idT=0; idT < this._listTemp.length; idT++ ) {\n\t    template = this._listTemp[idT];\n\t    if( this._lastChar === template.pat[template.pos] ) {\n\t\ttemplate.pos += 1;\n\t\t//DEBUG console.log( \"__CHECK : pat=\"+template.pat+\" pos=\"+template.pos );\n\t\t// Pattern totaly matched ?\n\t\tif( template.pos === template.pat.length ) {\n\t\t    //DEBUG console.log( \"__CHECK => found \"+template.pat );\n\t\t    this._state = \"PATTERN\";\n\t\t    this._template = template;\n\t\t    \n\t\t    break; // get out of loop\n\t\t}\n\t    }\n\t    else {\n\t\ttemplate.pos = 0;\n\t\t//DEBUG console.log( \"__CHECK : pat=\"+template.pat+\" pos=\"+template.pos );\n\t    }\n\t}\n    }\n    // a pattern\n    else if( this._state === \"PATTERN\" || this._state === \"SELECT\" ) {\n\t// Pattern below cursor : undefined if no pattern\n\tvar pattern = extractPattern( val, curPos, this._template );\n\tif( key === 13 ) { // ENTER\n\t    //DEBUG console.log( \"KEY : Enter\" );\n    \t    // Choice made in the displayNode ?\n    \t    var selected = this._idxChoice > -1 && this._idxChoice !== this._maxMatch;\n    \t    //DEBUG console.log( \"   > sel=\"+selected+\" len=\"+this._bestChoices.length );\n    \t    if( selected ) {\n    \t\t//DEBUG console.log( \"   > selected\" );\n\t\tvar temp = this._bestMatches[this._idxChoice];\n\t      var str = temp.str;\n              // if str is \"<hr>\" or \"...\", abort\n              if (str === \"<hr>\" || str === \"...\") {\n                this._abortPattern( this._popNode );\n                this._areaNode.focus();\n                return;\n              }\n\t\tif( this._template.field === \"body\" ) {\n\t\t    str = $tw.wiki.getTiddlerText( temp.title );\n\t\t}\n    \t\tinsertInto( this._areaNode,\n\t\t\t    str,\n\t\t\t    pattern.start, curPos, this._template );\n\t\t// save this new content\n\t\tthis._widget.saveChanges( this._areaNode.value );\n\t    }\n\t    // otherwise take the first choice (if exists)\n\t    else if( this._bestMatches.length > 0 ) {\n    \t\t//DEBUG console.log( \"   > take first one\" );\n\t\tvar temp = this._bestMatches[0];\n\t      var str = temp.str;\n              // if str is \"<hr>\" or \"...\", abort\n              if (str === \"<hr>\" || str === \"...\") {\n                this._abortPattern( this._popNode );\n                this._areaNode.focus();\n                return;\n              }\n\t\tif( this._template.field === \"body\" ) {\n\t\t    str = $tw.wiki.getTiddlerText( temp.title );\n\t\t}\n    \t\tinsertInto( this._areaNode,\n\t\t\t    str,\n\t\t\t    pattern.start, curPos, this._template );\n\t\t// save this new content\n\t\tthis._widget.saveChanges( this._areaNode.value );\n\t    }\n\t    this._abortPattern( this._popNode );\n\t\t//DEBUG this._logStatus( \"\" );\n    \t    }\n\t    else if( key === 38 && this._hasInput === false) { // up\n\t\tthis._state = \"SELECT\";\n    \t\tevent.preventDefault();\n    \t\tthis._previous( this._popNode );\n\t\t//DEBUG this._logStatus( pattern.text );\n    \t\t//event.stopPropagation();\n    \t    }\n    \t    else if( key === 40 && this._hasInput === false) { // down\n\t\tthis._state = \"SELECT\";\n    \t\tevent.preventDefault();\n    \t\tthis._next( this._popNode );\n\t\t//DEBUG this._logStatus( pattern.text );\n    \t\t//event.stopPropagation();\n    \t    }\n    \t    else if( pattern ) { // pattern changed by keypressed\n\t\tthis._idxChoice = -1;\n    \t\t// log\n                //DEBUG console.log( \"  PATTERN changed\" );\n\t\t//DEBUG this._logStatus( pattern.text );\n                //DEBUG console.log( \"  pat.length\",pattern.text.length, \" min\",this._minPatLength);\n    \t\t// Popup with choices if pattern at least minPatLength letters long\n\t\tif( pattern.text.length > (this._minPatLength-1) ) {\n                    //DEBUG console.log( \"  should compute\" );\n\t\t    // compute listOptions from templateFilter\n\t\t    var allOptions;\n\t\t    if( this._template )\n\t\t\tallOptions = this._widget.wiki.filterTiddlers( this._template.filter );\n\t\t    else\n\t\t\tallOptions = this._widget.wiki.filterTiddlers(\"[all[tiddlers]]\");\n\t\t    this._findBestMatches( allOptions, pattern.text );\n    \t\t    this._popNode.innerHTML = \"\";\n    \t\t    //console.log( \"BC \"+ this._pattern + \" => \" + choice );\n    \t\t    if (this._bestMatches.length > 0) {\n\t\t      for( var i=0; i<this._bestMatches.length; i++) {\n                        let li_elem = itemHTML(this._bestMatches[i].str,\n\t\t\t\t\t       pattern.text);\n                        // pass this as comp to eventHandler\n                        li_elem.addEventListener( \"click\",\n                                                  function( idx, event) {\n                                                    //DEBUG console.log( \"__ITEM Listener\", this, idx, event );\n                                                    this.handleItemClik( idx );\n                                                  }.bind(this,i));\n                        li_elem.addEventListener( \"touchstart\",\n                                                  function( idx, event) {\n                                                    //comp is the completion object, passed using 'bind' \n                                                    this.handleItemClik( idx );\n                                                  }.bind(this,i));\n                        li_elem.addEventListener( \"mouseover\",\n                                                  function( idx, event) {\n                                                    this._goto( this._popNode,\n                                                                idx );\n                                                  }.bind(this,i));\n                        \n                        // li_elem.addEventListener( \"click\",\n                        //                           this.handleItemClick );\n    \t\t\tthis._popNode.appendChild( li_elem );\n    \t\t      }\n\t\t      this._display( this._areaNode, this._popNode );\t\t\t\n    \t\t    }\n\t\t    else { // no matches\n\t\t\tthis._state = \"PATTERN\";\n\t\t\tthis._undisplay( this._popNode );\n\t\t    }\n\t\t}\n    \t    }\n\t    else { // no pattern detected\n\t\tthis._abortPattern( this._popNode );\n\t    }\n\t}\n\t// to ensure that one MUST add an input (through onInput())\n\tthis._hasInput = false;\n};\n// not real event handler as awaits the index of the clicked/touched bestChoice\nCompletion.prototype.handleItemClik = function( idx_select) {\n  \n  var curPos = this._areaNode.selectionStart;  // cursor position\n  var val = this._areaNode.value;   // text in the area\n  var pattern = extractPattern( val, curPos, this._template );\n  \n  //DEBUG console.log( \"__handleItemClik idx=\"+idx_select, this );\n  \n  // insert choice into document\n  var temp = this._bestMatches[idx_select];\n  var str = temp.str;\n\n  // if str is \"<hr>\" or \"...\", abort\n  if (str === \"<hr>\" || str === \"...\") {\n    this._abortPattern( this._popNode );\n    this._areaNode.focus();\n    return;\n  }\n  \n  if( this._template.field === \"body\" ) {\n    str = $tw.wiki.getTiddlerText( temp.title );\n  }\n  insertInto( this._areaNode,\n\t      str,\n\t      pattern.start, curPos, this._template );\n  // save this new content\n  this._widget.saveChanges( this._areaNode.value );\n  this._abortPattern( this._popNode );\n  this._areaNode.focus();\n  //DEBUG this._logStatus( \"\" );\n}\n// **************************************************************************\n// ******************************************************** private functions\n// **************************************************************************\n/**\n * Create popup element.\n */\nvar createPopup = function( widget, node ) {\n    // Insert a special \"div\" element for poping up\n    // Its 'display' property in 'style' control its visibility\n    var popupNode = widget.document.createElement(\"div\");\n    popupNode.setAttribute( \"style\", \"display:none; position: absolute;\");\n    popupNode.className = \"tc-block-dropdown ect-block-dropdown\";\n    // Insert the element into the DOM\n    node.parentNode.insertBefore(popupNode,node.nextSibling);\n    //CHECK the domNodes is a attribute of Widget [widget.js]\n    //CHECK this.domNodes.push(popupNode);\n    \n    return popupNode;\n};\n/**\n * Extract Pattern from text at a given position.\n *\n * Between previous template.pat (or '[[') and pos\n * \n * If no pattern -> undefined\n */\nvar extractPattern = function( text, pos, template ) {\n    // Detect previous and next ]]=>STOP or [[=>START\n    var sPat = template.pat ? template.pat : '[[';\n    var pos_prevOpen = text.lastIndexOf( sPat, pos );\n    var ePat = template.end ? template.end : ']]';\n    var pos_prevClosed = text.lastIndexOf( ePat, pos );\n    var pos_nextClosed = text.indexOf( ePat, pos  );\n    //DEBUG console.log(\"__CALC st=\"+sPat+\" -> en=\"+ePat );\n    //DEBUG console.log(\"__CALC po=\"+pos_prevOpen+\" pc=\"+pos_prevClosed+\" nc=\"+pos_nextClosed+\" pos=\"+pos);\n    pos_nextClosed = (pos_nextClosed >= 0) ? pos_nextClosed : pos;\n    \n    if( (pos_prevOpen >= 0) &&                 // must be opened\n\t((pos_prevOpen > pos_prevClosed ) ||  // not closed yet\n\t (pos_prevClosed === pos))) {          // closed at cursor\n\t//DEBUG console.log(\"     pat=\"+text.slice( pos_prevOpen+sPat.length, pos) );\n\treturn { text: text.slice( pos_prevOpen+sPat.length, pos ),\n\t\t start: pos_prevOpen,\n\t\t end: pos_nextClosed\n\t       };\n    }\n};\n/**\n * Controls how list items are generated.\n * Function that takes two parameters :\n *  - text : suggestion text\n *  - input : the user’s input\n * Returns : list item. \n * Generates list items with the user’s input highlighted via <mark>.\n */\n  var itemHTML = function (text, input) {\n    // text si input === ''\n    // otherwise, build RegExp that is global (g) and case insensitive (i)\n    // to replace with <mark>$&</mark> where \"$&\" is the matched pattern\n  var html = input === '' ? text : text.replace(RegExp(regExpEscape(input.trim()), \"gi\"), \"<mark>$&</mark>\");\n  // the DOM element created\n  var elem = create(\"li\", {\n    innerHTML: html,\n    \"patt-selected\": \"false\",\n  });\n  return elem; \n};\n/**\n * Insert text into a textarea node, \n * enclosing in 'template.start..template.end'\n *\n * - posBefore : where the 'template.pat+pattern' starts\n * - posAfter : where the cursor currently is\n */\nvar insertInto = function(node, text, posBefore, posAfter, template ) {\n    //DEBUG console.log( \"__INSERT : \"+template.pattern+\":\"+template.filter+\":\"+template.mask+\":\"+template.field+\":\"+template.start+\":\"+template.end );\n    var val = node.value;\n    var sStart = template.start !== undefined ? template.start : '[[';\n    var sEnd = template.end !== undefined ? template.end : ']]';\n    var newVal = val.slice(0, posBefore) + sStart + text + sEnd + val.slice(posAfter);\n    //console.log(\"__INSERT s=\"+sStart+\" e=\"+sEnd);\n    //console.log (\"__INSERT pb=\"+posBefore+\" pa=\"+posAfter+\" txt=\"+text);\n    //console.log( \"NEW VAL = \"+newVal );\n    // WARN : Directly modifie domNode.value.\n    // Not sure it does not short-circuit other update methods of the domNode....\n    // i.e. could use widget.updateEditor(newVal) from edit-comptext widget.\n    //      but how to be sure that cursor is well positionned ?\n    node.value = newVal;\n\n    // if startOffset in Template, set cursor at beginning of inserted value,\n    // with an Offset (usefull for aliasing links)\n    if (template.startOffset) {\n        let cursorPos = posBefore+template.startOffset;\n        node.setSelectionRange( cursorPos, cursorPos );\n    }\n    else {\n        node.setSelectionRange(posBefore+text.length+sStart.length+sEnd.length, posBefore+text.length+sStart.length+sEnd.length );\n    }\n};\n/**\n * Add an '\\' in front of -\\^$*+?.()|[]{}\n */\nvar regExpEscape = function (s) {\n    return s.replace(/[-\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n};\n/**\n * Add an element in the DOM.\n */\nvar create = function(tag, o) {\n    var element = document.createElement(tag);\n    \n    for (var i in o) {\n\tvar val = o[i];\n\t\n\tif (i === \"inside\") {\n\t    $(val).appendChild(element);\n\t}\n\telse if (i === \"around\") {\n\t    var ref = $(val);\n\t    ref.parentNode.insertBefore(element, ref);\n\t    element.appendChild(ref);\n\t}\n\telse if (i in element) {\n\t    element[i] = val;\n\t}\n\telse {\n\t    element.setAttribute(i, val);\n\t}\n    }\n    \n    return element;\n};\n\n\nexports.Completion = Completion;\n\n})();\n\n    \n",
            "type": "application/javascript",
            "title": "$:/plugins/snowgoon88/edit-comptext/completion.js",
            "module-type": "library"
        },
        "$:/plugins/snowgoon88/edit-comptext/edit-comptext.css": {
            "text": "\n\\rules only filteredtranscludeinline transcludeinline macrodef macrocallinline macrocallblock\n\n/* The \\rules pragma at the top of the tiddler restricts the WikiText \n * to just allow macros and transclusion. This avoids mistakenly \n * triggering unwanted WikiText processing.\n * \n * MUST not save as text/css for macro to be processed\n*/\n\n.ect-block-dropdown li {\n    display: block;\n    padding: 4px 14px 4px 14px;\n    text-decoration: none;\n    color: <<colour tiddler-link-foreground>>; /*#5778d8;*/ \n    background: transparent;\n}\n.ect-block-dropdown li[patt-selected=\"true\"] {\n    color: <<colour tiddler-link-background>>; /*#ffffff; */\n    background-color: <<colour tiddler-link-foreground>>; /*#5778d8; */\n}\n.ect-block-dropdown li[patt-selected=\"true\"] mark {\n    background: hsl(86, 100%, 21%);\n    color: inherit;\n}\n\n",
            "type": "text/vnd.tiddlywiki",
            "title": "$:/plugins/snowgoon88/edit-comptext/edit-comptext.css",
            "tags": "[[$:/tags/Stylesheet]]"
        },
        "$:/plugins/snowgoon88/edit-comptext/readme": {
            "title": "$:/plugins/snowgoon88/edit-comptext/readme",
            "text": "!! What ?\nThis plugin adds ''completion'' when editing the body of a tiddler.\n\n* Enter completion-mode by typing `[[` or `CTRL+SPACE`\n* A list of tiddlers with a title that matches the pattern between `[[` and cursor appears\n* `UP/DOWN` keys can select a tiddler, `ENTER` to validate\n* `NEW` : can click with mouse or touch surface to select your completion.\n* If there is only one match, `ENTER` selects it.\n* you can specify you own trigger pattern and the list of possible completions. See [[$:/plugins/snowgoon88/edit-comptext/usage]] for more details.\n* `NEW` : after completion, the cursor can be set inside the inserted text. This allows for easier creation of \"aliased links\" (try completion with `||` for example).\n* `NEW` : version 0.9.1 and higher, the default TW5 editor automatically has autocompletion as soon as the plugin is enabled (if TW5 version 5.1.22 or higher)\n\n!! To try it or get the latest news\nSee [[http://snowgoon88.github.io/TW5-extendedit]]\n\n!! Install \n\nTo add the plugin to your own TiddlyWiki5, just drag this link to the browser window:\n\n[[$:/plugins/snowgoon88/edit-comptext]]\n\nSometime (prior to TW5.1.22), a small configuration step is then needed\n\nin `$:/ControlPanel -> Advanced -> Editor Type -> text/vnd.tiddlywiki` you must chose `comptext` instead of `text`.\n\nReload and « voilà »...\n\nThis plugin is quite mature now :o)\n\n!! Old version\n\n* A version compatible with 5.0.8 to 5.1.11 : [[http://snowgoon88.github.io/TW5-extendedit/index_5.1.11.html]]\n\n!! Source code\nOn github [[https://github.com/snowgoon88/TW5-extendedit]]\n\nGet in touch : snowgoon88(AT)gmail(DOT)com\n"
        },
        "$:/plugins/snowgoon88/edit-comptext/usage": {
            "title": "$:/plugins/snowgoon88/edit-comptext/usage",
            "text": "Now, this plugin should be automatically integrated in the common editors.\n\nIn some older version of Tiddlywiki, you might have to change things in `$:/ControlPanel -> Advanced -> Editor Type -> text/vnd.tiddlywiki` to put `comptext` instead of `text`.\n\nConfiguration of the edit-comptext plugin can be done through the tiddler [[$:/plugins/snowgoon88/edit-comptext/config]]. Use a JSON tiddler (do not forget to set the type to `application/json`. See some examples at [[$:/plugins/snowgoon88/edit-comptext/examples]]\n\nIn the `configuration` object you can set :\n\n* `caseSensitive`: `true`/`false` (is search case sensitive ?)\n* `maxMatch` : an `integer` (max number of match displayed)\n* `minPatLength` : an `integer` (minimal length of a pattern to trigger completion search)\n* `triggerKeyCombination ` : a `string` representing the key combination that triggers the autocompletion popup. To use modifier keys in your combination, use following conversions : `ctrl` -> `^`, `alt` -> `!`, `shift` -> `+`. Note: ` ` (literally a whitespace) represents the `space` key.\n\nIn the `template` array you can specify the various completion templates that will be used. Every template can have the following members.\n\n* `pattern` : `string` (pattern that triggers a completion, default \"[[\" )\n* `title` or `body`: `string` (the filter operators that gives the list of valid completions, default \"[all[tiddlers]!is[system]]\"). If you specify `body`, then the body of the tiddler will be inserted on selection.\n* `start` : `string` (when completion is chosen, start is put before the completion, default \"[[\")\n* `end` : `string` (when completion is chosen, end is put after the completion, default \"]]\")\n* `startOffset` : `interger` but OPTIONNAL. If provided, the cursor will be positionned `startOffset` characters after the beginning of the completed text. This is useful to create aliased links using \"||\" as a trigger.\n\n!! Current body of Config Tiddler\n\n{{$:/plugins/snowgoon88/edit-comptext/config}}\n\n"
        }
    }
}